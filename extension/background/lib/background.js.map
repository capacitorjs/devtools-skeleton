{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap e4ff2c31f2a01d80e87d","webpack:///./src/background.js","webpack:///./~/capacitor-devtools-helpers/lib/devtools-helpers.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA,aAAY,CAAC;;qDAEmB,CAA4B;;AAE5D,KAAM,aAAa,GAAG,gDAAgD,CAAC;AACvE,KAAM,eAAe,GAAG,kDAAkD,CAAC;AAC3E,6CAAkB,oBAAoB,CAAC,aAAa,EAAE,eAAe,CAAC,C;;;;;;ACNtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD,qCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU;AACV;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAE;;AAEF,wCAAuC,uCAAuC,kBAAkB;;AAEhG;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA,GAAE;;AAEF,qCAAoC,iCAAiC,eAAe,eAAe,gBAAgB,oBAAoB,MAAM,0CAA0C,+BAA+B,aAAa,qBAAqB,mCAAmC,EAAE,EAAE,cAAc,WAAW,UAAU,EAAE,UAAU,MAAM,yCAAyC,EAAE,UAAU,kBAAkB,EAAE,EAAE,aAAa,EAAE,2BAA2B,0BAA0B,YAAY,EAAE,2CAA2C,8BAA8B,EAAE,OAAO,6EAA6E,EAAE,GAAG,EAAE;;AAEvpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA0C,iBAAiB;;AAE3D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAM;AACN,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAQ;AACR,OAAM;AACN,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA,WAAU;AACV,SAAQ;AACR;AACA,OAAM;AACN,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,QAAQ;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR,OAAM;AACN;AACA;AACA;;AAEA;;AAEA;AACA,OAAM;AACN;AACA;AACA;;AAEA,QAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA,GAAE;;AAEF,wCAAuC,uCAAuC,kBAAkB;;AAEhG;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA,GAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA,GAAE;;AAEF,wCAAuC,uCAAuC,kBAAkB;;AAEhG;;AAEA;;AAEA;AACA;AACA;AACA,2CAA0C,iBAAiB;AAC3D;AACA;AACA,8BAA6B,mBAAmB;AAChD;AACA;AACA;AACA;;AAEA;AACA,OAAM;AACN,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;;AAEA,QAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA,GAAE;;AAEF,6CAA4C,kBAAkB,kCAAkC,qEAAqE,EAAE,EAAE,OAAO,kBAAkB,EAAE,YAAY;;AAEhN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B;AAC3B,8BAA6B;AAC7B,0BAAyB;AACzB;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2DAA0D,qBAAqB;AAC/E,SAAQ;AACR;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAgC,6BAA6B;AAC7D,SAAQ;AACR;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAM;;AAEN,wBAAuB,6BAA6B;AACpD,KAAI;;AAEJ;AACA;AACA,kCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oCAAmC;AACnC;AACA,OAAM;AACN;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAC;AACD;AACA,6C","file":"background.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap e4ff2c31f2a01d80e87d\n **/","'use strict';\n\nimport {BackgroundHelpers} from 'capacitor-devtools-helpers';\n\nconst panelPortName = 'github.com/capacitorjs/devtools-skeleton:panel';\nconst contentPortName = 'github.com/capacitorjs/devtools-skeleton:content';\nBackgroundHelpers.initializeBackground(panelPortName, contentPortName);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/background.js\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tvar _panelHelpersJs = __webpack_require__(1);\n\t\n\tvar _panelHelpersJs2 = _interopRequireDefault(_panelHelpersJs);\n\t\n\tvar _injectedHelpersJs = __webpack_require__(2);\n\t\n\tvar _injectedHelpersJs2 = _interopRequireDefault(_injectedHelpersJs);\n\t\n\tvar _contentHelpersJs = __webpack_require__(4);\n\t\n\tvar _contentHelpersJs2 = _interopRequireDefault(_contentHelpersJs);\n\t\n\tvar _backgroundHelpersJs = __webpack_require__(5);\n\t\n\tvar _backgroundHelpersJs2 = _interopRequireDefault(_backgroundHelpersJs);\n\t\n\texports['default'] = {\n\t  PanelHelpers: _panelHelpersJs2['default'],\n\t  InjectedHelpers: _injectedHelpersJs2['default'],\n\t  ContentHelpers: _contentHelpersJs2['default'],\n\t  BackgroundHelpers: _backgroundHelpersJs2['default']\n\t};\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\n\t\n\texports['default'] = {\n\t  /**\n\t   * Connect to the bacground page,\n\t   * immediately initializing any scripts and listening for messages to forward\n\t   * @param emitter a node-sytle EventEmitter\n\t   */\n\t  connectToBackground: function connectToBackground(portName) {\n\t    return new Promise(function (resolve) {\n\t      // Create a connection to the background page\n\t      var port = chrome.runtime.connect({ name: portName });\n\t\n\t      var listener = function listener(message) {\n\t        if (message.name === 'background:connect') {\n\t          port.onMessage.removeListener(listener);\n\t          resolve(port);\n\t        }\n\t      };\n\t\n\t      // tunnel from injected to emitter\n\t      port.onMessage.addListener(listener);\n\t    });\n\t  },\n\t\n\t  /**\n\t   * Inject the given content script.\n\t   * Requires the cooperation of background-helpers\n\t   * @param port\n\t   * @param contentScript\n\t   * @returns {Promise}\n\t   */\n\t  injectContent: function injectContent(port, contentScript) {\n\t    return new Promise(function (resolve) {\n\t      var listener = function listener(message) {\n\t        if (message.name === 'content:registered') {\n\t          port.onMessage.removeListener(listener);\n\t          resolve();\n\t        }\n\t      };\n\t\n\t      port.onMessage.addListener(listener);\n\t\n\t      port.postMessage({\n\t        name: 'register-content',\n\t        contentTabId: chrome.devtools.inspectedWindow.tabId,\n\t        file: contentScript\n\t      });\n\t    });\n\t  },\n\t\n\t  /**\n\t   * Tunnel events from the background page to the message emitter\n\t   * and from the message emitter to the background page\n\t   * Requires the cooperation of background-helpers, content-helpers, and injected-helpers\n\t   * @param port a chrome.runtime.Port\n\t   * @param emitter a node-style EventEmitter\n\t   * @return () -> void A function that disposes of the listeners\n\t   */\n\t  proxyEvents: function proxyEvents(port, emitter) {\n\t    var backgroundListener = function backgroundListener(message) {\n\t      if (message.name === 'tunnel:panel') {\n\t        emitter.emit(message.event, message.payload);\n\t      }\n\t    };\n\t\n\t    var panelListener = function panelListener(event, payload) {\n\t      port.postMessage({\n\t        name: 'tunnel:injected',\n\t        event: event,\n\t        payload: payload\n\t      });\n\t    };\n\t\n\t    var toInjected = 'tunnel:injected';\n\t    emitter.on(toInjected, panelListener);\n\t    port.onMessage.addListener(backgroundListener);\n\t\n\t    return function () {\n\t      emitter.removeListener(toInjected, panelListener);\n\t      port.onMessage.removeListener(backgroundListener);\n\t    };\n\t  },\n\t\n\t  /**\n\t   * Inject the given script file into the inspected window\n\t   * @param scriptFile\n\t   */\n\t  injectScript: function injectScript(scriptFile) {\n\t    return new Promise(function (resolve, reject) {\n\t      // URL scheme \"chrome-extension\" is not supported by Chrome's fetch yet\n\t      var injectedXHR = new XMLHttpRequest();\n\t      injectedXHR.open('get', scriptFile, true);\n\t      injectedXHR.addEventListener('load', function (xhrResult) {\n\t        var injectedScript = xhrResult.target.response;\n\t        chrome.devtools.inspectedWindow.eval(injectedScript, function (result, isException) {\n\t          if (isException) {\n\t            reject(result);\n\t          } else {\n\t            resolve(result);\n\t          }\n\t        });\n\t      });\n\t      injectedXHR.send();\n\t    });\n\t  },\n\t\n\t  /**\n\t   * A convenience method to forward messages, inject a content page,\n\t   * and inject an inspected script\n\t   *\n\t   * Note that this does not provide the convenient ability to tear down listeners,\n\t   * as it assumes the event-listening will be running for the lifetime of the application\n\t   * @param portName\n\t   * @param emitter a node-sytle event emitter\n\t   * @param contentScript the location of the content script to inject\n\t   * @param inspectedScript the location of the script to inject into the inspected window\n\t   * @returns {Promise} resolves when all scripts are injected\n\t   */\n\t  initializePanel: function initializePanel(portName, emitter, contentScript, inspectedScript) {\n\t    var _this = this;\n\t\n\t    var background = this.connectToBackground(portName);\n\t    var content = background.then(function (port) {\n\t      _this.proxyEvents(port, emitter);\n\t      return _this.injectContent(port, contentScript).then(function () {\n\t        return port;\n\t      });\n\t    });\n\t    var injected = this.injectScript(inspectedScript);\n\t    return Promise.all([content, injected]).then(function (_ref) {\n\t      var _ref2 = _slicedToArray(_ref, 1);\n\t\n\t      var port = _ref2[0];\n\t\n\t      return port;\n\t    });\n\t  }\n\t};\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tvar _tunnelUtilsJs = __webpack_require__(3);\n\t\n\tvar _tunnelUtilsJs2 = _interopRequireDefault(_tunnelUtilsJs);\n\t\n\texports['default'] = {\n\t  /**\n\t   * Tunnel events from the content script to the emitter\n\t   * and from the emitter to the content script\n\t   *\n\t   * @return a function that tears down the listeners\n\t   */\n\t  proxyEvents: function proxyEvents(emitter) {\n\t    // publish content script messages to the emitter\n\t    var contentToEmitter = _tunnelUtilsJs2['default'].tunnelEvents('tunnel:injected', function (message) {\n\t      emitter.emit(message.event, message.payload);\n\t    });\n\t\n\t    // publish emitter events to the content script\n\t    var emitterToContent = function emitterToContent(event, payload) {\n\t      window.postMessage({\n\t        name: 'tunnel:panel',\n\t        event: event,\n\t        payload: payload\n\t      }, '*');\n\t    };\n\t\n\t    window.addEventListener('message', contentToEmitter);\n\t    emitter.on('tunnel:panel', emitterToContent);\n\t\n\t    return function () {\n\t      window.removeEventListener('message', contentToEmitter);\n\t      emitter.removeListener('tunnel:panel', emitterToContent);\n\t    };\n\t  }\n\t};\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports['default'] = {\n\t  /**\n\t   * Wraps the givent function, ensuring that it will only be called\n\t   * when the message has the given eventName and originates from the same window\n\t   */\n\t  tunnelEvents: function tunnelEvents(eventName, fn) {\n\t    return function (event) {\n\t      var message = event.data;\n\t      if (event.source !== window || typeof message !== 'object' || message == null || message.name !== eventName) {\n\t        return;\n\t      }\n\t      fn(message);\n\t    };\n\t  }\n\t};\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tvar _tunnelUtilsJs = __webpack_require__(3);\n\t\n\tvar _tunnelUtilsJs2 = _interopRequireDefault(_tunnelUtilsJs);\n\t\n\texports['default'] = {\n\t  connectToBackground: function connectToBackground(portName) {\n\t    return new Promise(function (resolve) {\n\t      var port = chrome.runtime.connect({ name: portName });\n\t      var listener = function listener(message) {\n\t        if (message.name === 'background:connect') {\n\t          port.postMessage({ name: 'register' });\n\t          port.onMessage.removeListener(listener);\n\t          resolve(port);\n\t        }\n\t      };\n\t\n\t      port.onMessage.addListener(listener);\n\t    });\n\t  },\n\t\n\t  /**\n\t   * Tunnel events from the injected script to the panel, and vice-versa\n\t   * Tunneling happens by means of the background page\n\t   */\n\t  proxyEvents: function proxyEvents(port) {\n\t    // tunnel events from the injected script to the panel\n\t    var injectedToPanel = _tunnelUtilsJs2['default'].tunnelEvents('tunnel:panel', function (message) {\n\t      port.postMessage(message);\n\t    });\n\t\n\t    // tunnel events from the panel to the injected script\n\t    var panelToInjected = function panelToInjected(message) {\n\t      if (message.name === 'tunnel:injected') {\n\t        window.postMessage(message, '*');\n\t      }\n\t    };\n\t\n\t    window.addEventListener('message', injectedToPanel);\n\t    port.onMessage.addListener(panelToInjected);\n\t\n\t    return function () {\n\t      window.removeEventListener('message', injectedToPanel);\n\t      port.onMessage.removeListener(panelToInjected);\n\t    };\n\t  },\n\t\n\t  /**\n\t   * A convenience method to connect to the background page and proxy events.\n\t   * Does not provide a convenient way to unregister events,\n\t   * as it assumes the listeners will live for the length of the application\n\t   * @return the port\n\t   */\n\t  initializeContent: function initializeContent(portName) {\n\t    var _this = this;\n\t\n\t    return this.connectToBackground(portName).then(function (port) {\n\t      _this.proxyEvents(port);\n\t      return port;\n\t    });\n\t  }\n\t};\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\t\n\tvar tabIdFromPort = function tabIdFromPort(port) {\n\t  return port.sender.tab.id;\n\t};\n\t\n\t/**\n\t * Helpers for working with the Devtools background page\n\t * inspired by https://developer.chrome.com/extensions/devtools#solutions\n\t */\n\texports['default'] = {\n\t  /**\n\t   * Create a registry object that will maintain the status of a background page\n\t   */\n\t  newRegistry: function newRegistry() {\n\t    return {\n\t      panelConnections: {},\n\t      contentConnections: {},\n\t      panelToContent: {},\n\t      contentToPanel: {}\n\t    };\n\t  },\n\t\n\t  /**\n\t   * Return a new listener function that responds to messages from the panel\n\t   * the message that the listener is called with determines the outcome:\n\t   *\n\t   * tunnel:injected -- forward the message to the appropriate content script\n\t   * register-content -- tells the background page to inject the given content script\n\t   */\n\t  newPanelListener: function newPanelListener(registry) {\n\t    return function (message, sendingPort) {\n\t      var panelId = tabIdFromPort(sendingPort);\n\t\n\t      if (message.name === 'register-content') {\n\t        registry.panelToContent[panelId] = message.contentTabId;\n\t        registry.contentToPanel[message.contentTabId] = panelId;\n\t        chrome.tabs.executeScript(message.contentTabId, { file: message.file });\n\t      } else if (message.name === 'tunnel:injected') {\n\t        var contentPort = registry.contentConnections[registry.panelToContent[panelId]];\n\t        contentPort.postMessage(message);\n\t      }\n\t    };\n\t  },\n\t\n\t  /**\n\t   * Return a new listener function that responds to messages from the content page\n\t   * the message that the listener is called with determines the outcome:\n\t   *\n\t   * tunnel:panel -- forward the message to the appropriate panel\n\t   * register -- inform the panel that the content script has been registered\n\t   */\n\t  newContentListener: function newContentListener(registry) {\n\t    return function (message, sendingPort) {\n\t      var contentId = tabIdFromPort(sendingPort);\n\t      var panelPort = registry.panelConnections[registry.contentToPanel[contentId]];\n\t      if (message.name === 'register') {\n\t        panelPort.postMessage({ name: 'content:registered' });\n\t      } else if (message.name === 'tunnel:panel') {\n\t        panelPort.postMessage(message);\n\t      }\n\t    };\n\t  },\n\t\n\t  /**\n\t   * Register a connection from a port, caching its connection,\n\t   * attacting a listener, and preparing for event teardown\n\t   */\n\t  registerConnection: function registerConnection(port, connections, idCache, listener) {\n\t    var id = tabIdFromPort(port);\n\t    connections[id] = port;\n\t    port.onMessage.addListener(listener);\n\t\n\t    port.onDisconnect.addListener(function () {\n\t      port.onMessage.removeListener(listener);\n\t      delete connections[id];\n\t      delete idCache[id];\n\t    });\n\t\n\t    port.postMessage({ name: 'background:connect' });\n\t  },\n\t\n\t  /**\n\t   * Handle a port connections based on port name\n\t   * accepts an object of type {[portName]: function (port) -> void}\n\t   *\n\t   * When a port connects, the handler registered with that port's name will be\n\t   * called with the port.\n\t   */\n\t  handleConnections: function handleConnections(portMap) {\n\t    var listener = function listener(port) {\n\t      var handler = portMap[port.name];\n\t      if (handler) {\n\t        handler(port);\n\t      }\n\t    };\n\t\n\t    chrome.runtime.onConnect.addListener(listener);\n\t    return function () {\n\t      chrome.runtime.onConnect.removeListener(listener);\n\t    };\n\t  },\n\t\n\t  /**\n\t   * A convenience method to handle connections\n\t   * with the default handling of panel ports and content ports\n\t   * sending messages back and forth\n\t   *\n\t   * Does not return an easy way of tearing down,\n\t   * because it is meant to last for the lifetime of the background page.\n\t   *\n\t   * However, individual port connections will be properly torn down.\n\t   */\n\t  initializeBackground: function initializeBackground(panelPortName, contentPortName) {\n\t    var _handlers,\n\t        _this = this;\n\t\n\t    var registry = this.newRegistry();\n\t    var panelListener = this.newPanelListener(registry);\n\t    var contentListener = this.newContentListener(registry);\n\t    var handlers = (_handlers = {}, _defineProperty(_handlers, panelPortName, function (port) {\n\t      _this.registerConnection(port, registry.panelConnections, registry.panelToContent, panelListener);\n\t    }), _defineProperty(_handlers, contentPortName, function (port) {\n\t      _this.registerConnection(port, registry.contentConnections, registry.contentToPanel, contentListener);\n\t    }), _handlers);\n\t    this.handleConnections(handlers);\n\t    return registry;\n\t  }\n\t};\n\tmodule.exports = exports['default'];\n\n/***/ }\n/******/ ])\n});\n;\n//# sourceMappingURL=devtools-helpers.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/capacitor-devtools-helpers/lib/devtools-helpers.js\n ** module id = 1\n ** module chunks = 0\n **/"],"sourceRoot":""}