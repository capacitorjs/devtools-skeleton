{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 6bd26b4d962f5cc0b9be","webpack:///./src/panel.js","webpack:///./~/gulp-capacitorjs-common/~/node-libs-browser/~/events/events.js","webpack:///./~/capacitor-devtools-helpers/lib/devtools-helpers.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA,aAAY,CAAC;;mCAEc,CAAQ;;qDACR,CAA4B;;AAEvD,KAAM,OAAO,GAAG,0BAAkB,CAAC;AACnC,KAAM,QAAQ,GAAG,gDAAgD,CAAC;AAClE,KAAM,OAAO,GAAG,wBAAwB,CAAC;AACzC,KAAM,QAAQ,GAAG,2BAA2B,CAAC;;AAE7C,wCAAa,eAAe,CAAC,QAAQ,EAAE,OAAO,EAAE,OAAO,EAAE,QAAQ,CAAC,CAAC,IAAI,CAAC,YAAY;;EAEnF,CAAC,C;;;;;;ACZF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,SAAS;AAC5B;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,gBAAe,SAAS;AACxB;;AAEA;AACA;AACA,gBAAe,SAAS;AACxB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,IAAG;AACH,qBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;AC5SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD,qCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU;AACV;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAE;;AAEF,wCAAuC,uCAAuC,kBAAkB;;AAEhG;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA,GAAE;;AAEF,qCAAoC,iCAAiC,eAAe,eAAe,gBAAgB,oBAAoB,MAAM,0CAA0C,+BAA+B,aAAa,qBAAqB,mCAAmC,EAAE,EAAE,cAAc,WAAW,UAAU,EAAE,UAAU,MAAM,yCAAyC,EAAE,UAAU,kBAAkB,EAAE,EAAE,aAAa,EAAE,2BAA2B,0BAA0B,YAAY,EAAE,2CAA2C,8BAA8B,EAAE,OAAO,6EAA6E,EAAE,GAAG,EAAE;;AAEvpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA0C,iBAAiB;;AAE3D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAM;AACN,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAQ;AACR,OAAM;AACN,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA,WAAU;AACV,SAAQ;AACR;AACA,OAAM;AACN,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,QAAQ;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR,OAAM;AACN;AACA;AACA;;AAEA;;AAEA;AACA,OAAM;AACN;AACA;AACA;;AAEA,QAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA,GAAE;;AAEF,wCAAuC,uCAAuC,kBAAkB;;AAEhG;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA,GAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA,GAAE;;AAEF,wCAAuC,uCAAuC,kBAAkB;;AAEhG;;AAEA;;AAEA;AACA;AACA;AACA,2CAA0C,iBAAiB;AAC3D;AACA;AACA,8BAA6B,mBAAmB;AAChD;AACA;AACA;AACA;;AAEA;AACA,OAAM;AACN,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;;AAEA,QAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA,GAAE;;AAEF,6CAA4C,kBAAkB,kCAAkC,qEAAqE,EAAE,EAAE,OAAO,kBAAkB,EAAE,YAAY;;AAEhN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B;AAC3B,8BAA6B;AAC7B,0BAAyB;AACzB;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2DAA0D,qBAAqB;AAC/E,SAAQ;AACR;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAgC,6BAA6B;AAC7D,SAAQ;AACR;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAM;;AAEN,wBAAuB,6BAA6B;AACpD,KAAI;;AAEJ;AACA;AACA,kCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oCAAmC;AACnC;AACA,OAAM;AACN;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAC;AACD;AACA,6C","file":"panel.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 6bd26b4d962f5cc0b9be\n **/","'use strict';\n\nimport {EventEmitter} from 'events';\nimport {PanelHelpers} from 'capacitor-devtools-helpers';\n\nconst emitter = new EventEmitter();\nconst portName = 'github.com/capacitorjs/devtools-skeleton:panel';\nconst content = 'content/lib/content.js';\nconst injected = '/injected/lib/injected.js';\n\nPanelHelpers.initializePanel(portName, emitter, content, injected).then(function () {\n  // start\n});\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/panel.js\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      }\n      throw TypeError('Uncaught, unspecified \"error\" event.');\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        len = arguments.length;\n        args = new Array(len - 1);\n        for (i = 1; i < len; i++)\n          args[i - 1] = arguments[i];\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    len = arguments.length;\n    args = new Array(len - 1);\n    for (i = 1; i < len; i++)\n      args[i - 1] = arguments[i];\n\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    var m;\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  var ret;\n  if (!emitter._events || !emitter._events[type])\n    ret = 0;\n  else if (isFunction(emitter._events[type]))\n    ret = 1;\n  else\n    ret = emitter._events[type].length;\n  return ret;\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/gulp-capacitorjs-common/~/node-libs-browser/~/events/events.js\n ** module id = 1\n ** module chunks = 0\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tvar _panelHelpersJs = __webpack_require__(1);\n\t\n\tvar _panelHelpersJs2 = _interopRequireDefault(_panelHelpersJs);\n\t\n\tvar _injectedHelpersJs = __webpack_require__(2);\n\t\n\tvar _injectedHelpersJs2 = _interopRequireDefault(_injectedHelpersJs);\n\t\n\tvar _contentHelpersJs = __webpack_require__(4);\n\t\n\tvar _contentHelpersJs2 = _interopRequireDefault(_contentHelpersJs);\n\t\n\tvar _backgroundHelpersJs = __webpack_require__(5);\n\t\n\tvar _backgroundHelpersJs2 = _interopRequireDefault(_backgroundHelpersJs);\n\t\n\texports['default'] = {\n\t  PanelHelpers: _panelHelpersJs2['default'],\n\t  InjectedHelpers: _injectedHelpersJs2['default'],\n\t  ContentHelpers: _contentHelpersJs2['default'],\n\t  BackgroundHelpers: _backgroundHelpersJs2['default']\n\t};\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tvar _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();\n\t\n\texports['default'] = {\n\t  /**\n\t   * Connect to the bacground page,\n\t   * immediately initializing any scripts and listening for messages to forward\n\t   * @param emitter a node-sytle EventEmitter\n\t   */\n\t  connectToBackground: function connectToBackground(portName) {\n\t    return new Promise(function (resolve) {\n\t      // Create a connection to the background page\n\t      var port = chrome.runtime.connect({ name: portName });\n\t\n\t      var listener = function listener(message) {\n\t        if (message.name === 'background:connect') {\n\t          port.onMessage.removeListener(listener);\n\t          resolve(port);\n\t        }\n\t      };\n\t\n\t      // tunnel from injected to emitter\n\t      port.onMessage.addListener(listener);\n\t    });\n\t  },\n\t\n\t  /**\n\t   * Inject the given content script.\n\t   * Requires the cooperation of background-helpers\n\t   * @param port\n\t   * @param contentScript\n\t   * @returns {Promise}\n\t   */\n\t  injectContent: function injectContent(port, contentScript) {\n\t    return new Promise(function (resolve) {\n\t      var listener = function listener(message) {\n\t        if (message.name === 'content:registered') {\n\t          port.onMessage.removeListener(listener);\n\t          resolve();\n\t        }\n\t      };\n\t\n\t      port.onMessage.addListener(listener);\n\t\n\t      port.postMessage({\n\t        name: 'register-content',\n\t        contentTabId: chrome.devtools.inspectedWindow.tabId,\n\t        file: contentScript\n\t      });\n\t    });\n\t  },\n\t\n\t  /**\n\t   * Tunnel events from the background page to the message emitter\n\t   * and from the message emitter to the background page\n\t   * Requires the cooperation of background-helpers, content-helpers, and injected-helpers\n\t   * @param port a chrome.runtime.Port\n\t   * @param emitter a node-style EventEmitter\n\t   * @return () -> void A function that disposes of the listeners\n\t   */\n\t  proxyEvents: function proxyEvents(port, emitter) {\n\t    var backgroundListener = function backgroundListener(message) {\n\t      if (message.name === 'tunnel:panel') {\n\t        emitter.emit(message.event, message.payload);\n\t      }\n\t    };\n\t\n\t    var panelListener = function panelListener(event, payload) {\n\t      port.postMessage({\n\t        name: 'tunnel:injected',\n\t        event: event,\n\t        payload: payload\n\t      });\n\t    };\n\t\n\t    var toInjected = 'tunnel:injected';\n\t    emitter.on(toInjected, panelListener);\n\t    port.onMessage.addListener(backgroundListener);\n\t\n\t    return function () {\n\t      emitter.removeListener(toInjected, panelListener);\n\t      port.onMessage.removeListener(backgroundListener);\n\t    };\n\t  },\n\t\n\t  /**\n\t   * Inject the given script file into the inspected window\n\t   * @param scriptFile\n\t   */\n\t  injectScript: function injectScript(scriptFile) {\n\t    return new Promise(function (resolve, reject) {\n\t      // URL scheme \"chrome-extension\" is not supported by Chrome's fetch yet\n\t      var injectedXHR = new XMLHttpRequest();\n\t      injectedXHR.open('get', scriptFile, true);\n\t      injectedXHR.addEventListener('load', function (xhrResult) {\n\t        var injectedScript = xhrResult.target.response;\n\t        chrome.devtools.inspectedWindow.eval(injectedScript, function (result, isException) {\n\t          if (isException) {\n\t            reject(result);\n\t          } else {\n\t            resolve(result);\n\t          }\n\t        });\n\t      });\n\t      injectedXHR.send();\n\t    });\n\t  },\n\t\n\t  /**\n\t   * A convenience method to forward messages, inject a content page,\n\t   * and inject an inspected script\n\t   *\n\t   * Note that this does not provide the convenient ability to tear down listeners,\n\t   * as it assumes the event-listening will be running for the lifetime of the application\n\t   * @param portName\n\t   * @param emitter a node-sytle event emitter\n\t   * @param contentScript the location of the content script to inject\n\t   * @param inspectedScript the location of the script to inject into the inspected window\n\t   * @returns {Promise} resolves when all scripts are injected\n\t   */\n\t  initializePanel: function initializePanel(portName, emitter, contentScript, inspectedScript) {\n\t    var _this = this;\n\t\n\t    var background = this.connectToBackground(portName);\n\t    var content = background.then(function (port) {\n\t      _this.proxyEvents(port, emitter);\n\t      return _this.injectContent(port, contentScript).then(function () {\n\t        return port;\n\t      });\n\t    });\n\t    var injected = this.injectScript(inspectedScript);\n\t    return Promise.all([content, injected]).then(function (_ref) {\n\t      var _ref2 = _slicedToArray(_ref, 1);\n\t\n\t      var port = _ref2[0];\n\t\n\t      return port;\n\t    });\n\t  }\n\t};\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tvar _tunnelUtilsJs = __webpack_require__(3);\n\t\n\tvar _tunnelUtilsJs2 = _interopRequireDefault(_tunnelUtilsJs);\n\t\n\texports['default'] = {\n\t  /**\n\t   * Tunnel events from the content script to the emitter\n\t   * and from the emitter to the content script\n\t   *\n\t   * @return a function that tears down the listeners\n\t   */\n\t  proxyEvents: function proxyEvents(emitter) {\n\t    // publish content script messages to the emitter\n\t    var contentToEmitter = _tunnelUtilsJs2['default'].tunnelEvents('tunnel:injected', function (message) {\n\t      emitter.emit(message.event, message.payload);\n\t    });\n\t\n\t    // publish emitter events to the content script\n\t    var emitterToContent = function emitterToContent(event, payload) {\n\t      window.postMessage({\n\t        name: 'tunnel:panel',\n\t        event: event,\n\t        payload: payload\n\t      }, '*');\n\t    };\n\t\n\t    window.addEventListener('message', contentToEmitter);\n\t    emitter.on('tunnel:panel', emitterToContent);\n\t\n\t    return function () {\n\t      window.removeEventListener('message', contentToEmitter);\n\t      emitter.removeListener('tunnel:panel', emitterToContent);\n\t    };\n\t  }\n\t};\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\texports['default'] = {\n\t  /**\n\t   * Wraps the givent function, ensuring that it will only be called\n\t   * when the message has the given eventName and originates from the same window\n\t   */\n\t  tunnelEvents: function tunnelEvents(eventName, fn) {\n\t    return function (event) {\n\t      var message = event.data;\n\t      if (event.source !== window || typeof message !== 'object' || message == null || message.name !== eventName) {\n\t        return;\n\t      }\n\t      fn(message);\n\t    };\n\t  }\n\t};\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tvar _tunnelUtilsJs = __webpack_require__(3);\n\t\n\tvar _tunnelUtilsJs2 = _interopRequireDefault(_tunnelUtilsJs);\n\t\n\texports['default'] = {\n\t  connectToBackground: function connectToBackground(portName) {\n\t    return new Promise(function (resolve) {\n\t      var port = chrome.runtime.connect({ name: portName });\n\t      var listener = function listener(message) {\n\t        if (message.name === 'background:connect') {\n\t          port.postMessage({ name: 'register' });\n\t          port.onMessage.removeListener(listener);\n\t          resolve(port);\n\t        }\n\t      };\n\t\n\t      port.onMessage.addListener(listener);\n\t    });\n\t  },\n\t\n\t  /**\n\t   * Tunnel events from the injected script to the panel, and vice-versa\n\t   * Tunneling happens by means of the background page\n\t   */\n\t  proxyEvents: function proxyEvents(port) {\n\t    // tunnel events from the injected script to the panel\n\t    var injectedToPanel = _tunnelUtilsJs2['default'].tunnelEvents('tunnel:panel', function (message) {\n\t      port.postMessage(message);\n\t    });\n\t\n\t    // tunnel events from the panel to the injected script\n\t    var panelToInjected = function panelToInjected(message) {\n\t      if (message.name === 'tunnel:injected') {\n\t        window.postMessage(message, '*');\n\t      }\n\t    };\n\t\n\t    window.addEventListener('message', injectedToPanel);\n\t    port.onMessage.addListener(panelToInjected);\n\t\n\t    return function () {\n\t      window.removeEventListener('message', injectedToPanel);\n\t      port.onMessage.removeListener(panelToInjected);\n\t    };\n\t  },\n\t\n\t  /**\n\t   * A convenience method to connect to the background page and proxy events.\n\t   * Does not provide a convenient way to unregister events,\n\t   * as it assumes the listeners will live for the length of the application\n\t   * @return the port\n\t   */\n\t  initializeContent: function initializeContent(portName) {\n\t    var _this = this;\n\t\n\t    return this.connectToBackground(portName).then(function (port) {\n\t      _this.proxyEvents(port);\n\t      return port;\n\t    });\n\t  }\n\t};\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\t\n\tvar tabIdFromPort = function tabIdFromPort(port) {\n\t  return port.sender.tab.id;\n\t};\n\t\n\t/**\n\t * Helpers for working with the Devtools background page\n\t * inspired by https://developer.chrome.com/extensions/devtools#solutions\n\t */\n\texports['default'] = {\n\t  /**\n\t   * Create a registry object that will maintain the status of a background page\n\t   */\n\t  newRegistry: function newRegistry() {\n\t    return {\n\t      panelConnections: {},\n\t      contentConnections: {},\n\t      panelToContent: {},\n\t      contentToPanel: {}\n\t    };\n\t  },\n\t\n\t  /**\n\t   * Return a new listener function that responds to messages from the panel\n\t   * the message that the listener is called with determines the outcome:\n\t   *\n\t   * tunnel:injected -- forward the message to the appropriate content script\n\t   * register-content -- tells the background page to inject the given content script\n\t   */\n\t  newPanelListener: function newPanelListener(registry) {\n\t    return function (message, sendingPort) {\n\t      var panelId = tabIdFromPort(sendingPort);\n\t\n\t      if (message.name === 'register-content') {\n\t        registry.panelToContent[panelId] = message.contentTabId;\n\t        registry.contentToPanel[message.contentTabId] = panelId;\n\t        chrome.tabs.executeScript(message.contentTabId, { file: message.file });\n\t      } else if (message.name === 'tunnel:injected') {\n\t        var contentPort = registry.contentConnections[registry.panelToContent[panelId]];\n\t        contentPort.postMessage(message);\n\t      }\n\t    };\n\t  },\n\t\n\t  /**\n\t   * Return a new listener function that responds to messages from the content page\n\t   * the message that the listener is called with determines the outcome:\n\t   *\n\t   * tunnel:panel -- forward the message to the appropriate panel\n\t   * register -- inform the panel that the content script has been registered\n\t   */\n\t  newContentListener: function newContentListener(registry) {\n\t    return function (message, sendingPort) {\n\t      var contentId = tabIdFromPort(sendingPort);\n\t      var panelPort = registry.panelConnections[registry.contentToPanel[contentId]];\n\t      if (message.name === 'register') {\n\t        panelPort.postMessage({ name: 'content:registered' });\n\t      } else if (message.name === 'tunnel:panel') {\n\t        panelPort.postMessage(message);\n\t      }\n\t    };\n\t  },\n\t\n\t  /**\n\t   * Register a connection from a port, caching its connection,\n\t   * attacting a listener, and preparing for event teardown\n\t   */\n\t  registerConnection: function registerConnection(port, connections, idCache, listener) {\n\t    var id = tabIdFromPort(port);\n\t    connections[id] = port;\n\t    port.onMessage.addListener(listener);\n\t\n\t    port.onDisconnect.addListener(function () {\n\t      port.onMessage.removeListener(listener);\n\t      delete connections[id];\n\t      delete idCache[id];\n\t    });\n\t\n\t    port.postMessage({ name: 'background:connect' });\n\t  },\n\t\n\t  /**\n\t   * Handle a port connections based on port name\n\t   * accepts an object of type {[portName]: function (port) -> void}\n\t   *\n\t   * When a port connects, the handler registered with that port's name will be\n\t   * called with the port.\n\t   */\n\t  handleConnections: function handleConnections(portMap) {\n\t    var listener = function listener(port) {\n\t      var handler = portMap[port.name];\n\t      if (handler) {\n\t        handler(port);\n\t      }\n\t    };\n\t\n\t    chrome.runtime.onConnect.addListener(listener);\n\t    return function () {\n\t      chrome.runtime.onConnect.removeListener(listener);\n\t    };\n\t  },\n\t\n\t  /**\n\t   * A convenience method to handle connections\n\t   * with the default handling of panel ports and content ports\n\t   * sending messages back and forth\n\t   *\n\t   * Does not return an easy way of tearing down,\n\t   * because it is meant to last for the lifetime of the background page.\n\t   *\n\t   * However, individual port connections will be properly torn down.\n\t   */\n\t  initializeBackground: function initializeBackground(panelPortName, contentPortName) {\n\t    var _handlers,\n\t        _this = this;\n\t\n\t    var registry = this.newRegistry();\n\t    var panelListener = this.newPanelListener(registry);\n\t    var contentListener = this.newContentListener(registry);\n\t    var handlers = (_handlers = {}, _defineProperty(_handlers, panelPortName, function (port) {\n\t      _this.registerConnection(port, registry.panelConnections, registry.panelToContent, panelListener);\n\t    }), _defineProperty(_handlers, contentPortName, function (port) {\n\t      _this.registerConnection(port, registry.contentConnections, registry.contentToPanel, contentListener);\n\t    }), _handlers);\n\t    this.handleConnections(handlers);\n\t    return registry;\n\t  }\n\t};\n\tmodule.exports = exports['default'];\n\n/***/ }\n/******/ ])\n});\n;\n//# sourceMappingURL=devtools-helpers.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/capacitor-devtools-helpers/lib/devtools-helpers.js\n ** module id = 2\n ** module chunks = 0\n **/"],"sourceRoot":""}